#  Copyright (c) 2009 Maciej Brodowicz
# 
#  Distributed under the Boost Software License, Version 1.0. (See accompanying 
#  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

This directory contains reimplementation of some of the hpx test codes in 
a variety of concurrent languages and environments: java, chapel, pthreads, 
cilk, etc. This is intended for performance comparisons between "our" and 
"their" version of functionally equivalent codes (at least as close as we 
can get), which could help detect inefficiencies and bugs in hpx.


fibonacci
---------
fib.chpl: chapel version, currently compiles with version 0.8 of the
chapel compiler. Performs one calculation per run. The argument value 
can be modified on the command line by using "--v=<number>" switch.

Fib2.java: performs 10 tests per invocation, reporting _average_ of all
previous and current timings in each iteration. Garbage collector is 
invoked at the end of each iteration (but not timed) to avoid pollution 
from previous runs. Takes one integer as command line argument.

pfib.c: simple pthread implementation; utilizes all cores on the node. 
Switch "-s" forces allocation of minimal stacks on systems that support 
this attribute (frequently results in order of magnitude speedups). 
Also, additional performance boost can be obtained by specifying 
"limit stacksize unlimited" on csh-compatible shells, or "ulimit -s 
unlimited" on bash before the execution. Switch "-v <number>" changes  
the argument. Note: use "-lpthread -lrt" to link on Linux.

pfibaff.c: as "pfib.c", but with forced thread affinity. Option "-t 
<number>" will cause the program to use only the first <number> of cores 
available on the system. The threads are assigned to cores based on the 
value of the thread input argument modulo <number>.

non-uniform workload on regular mesh
------------------------------------
mpiasym2d.c: MPI implementation of 2-D grid evolution with random amount 
of work per point. The workload pdf is described by its mean and standard 
deviation; supported distributions are "uniform" and "normal". The work 
is simulated by repeated accumulation of all values from square 
neighborhood of the point including (2*n+1)^2 mesh points, where n is the 
number of ghost cells; the final result per point is then obtained by 
dividing the computed sum by the product of (random) number of iterations 
and stencil size. The simulation degenerates to 1-D case (albeit 
inefficiently) when one of grid dimensions is given as 1; "-y 1" is 
preferred due to arrangement of arrays in memory.

mpiasym1dz.c: modified version of mpiasym2d.c to provide a better match 
for timing comparisons with amr example (also modified to include random 
workload emulation). The changes include introduction of fixed-size 
"zones" with localized uniform workload, pre-generation of workload data 
to avoid RNG invocations during measurements, periodic grid, and fixed 
1-D stencil (3 points).
