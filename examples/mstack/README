This file contains:
I.   Instructions for compiling Mstack
II.  Instructions for running Mstack. 
III. Details on the current HPX limitations where Mstack is concerned. 

-Mark Pellegrini (markpell@udel.edu)
August 2008
------------------------------------------------------------------


I.  To compile Mstack: 
------------------
(1) cmake .
(2) make 


II.  To run Mstack:
------------------
(1) Start the DGAS server:
../../runtime/hpx_runtime_pure <DGAS HOST IP> <PORT 1> <DGAS HOST IP> <PORT 2> 1

The normal DGAS server (../../runtime/hpx_runtime) listens on two ports. On the first port, it instantiates a full copy of the HPX runtime (just like any computation node). On the second, it provides the actual DGAS service. The pure version instantiates only a DGAS server. 

(2) Now run Mstack: 
./mstack <COMPUTATION NODE IP> <PORT 1> <DGAS SERVER IP> <PORT 2>  

The COMPUTATION NODE IP is the IP address of the node on which the master thread will run. This is almost certainly same as the computer the program is being run on (accessible via the ifconfig command). 

PORT 1 is the port on which Mstack will listen for packets. It is arbitrary. On Linux systems, I believe that ports 0-1024 are reserved for root; therefore, it is recommended to users to a port in the 10000+ range. 

The DGAS SERVER IP and PORT 2 are the same as from step 1. 

(3) Mstack will prompt the user to enter the number of channels (an int from 2 to 128, inclusive). These determine how much work the benchmark will do. The runtime increases as the square of the number of channels. 


III.   Current HPX Limitations:
------------

(1) The big one: The "Factory" lacks the ability to dynamically create components

In HPX, when a parcel (carrying a class to be run) is recieved by a destination, it needs to be converted into a thread. This necessitates allocating memory for it, calling the class's constructor function, and assigning it a GID. However, the HPX factory currently lacks the ability to instantiate any class except those hard coded into HPX. 

Hartmut says this will (may?) be fixed by September 15.
In the meantime, the work-around is to hard-code the Mstack class into the appropriate HPX libraries. 

(2) The medium one: HPX lacks a function retrieve a GID for one computation node 

HPX lacks a "give me 1 GID" function. The function should take no arguments, and return the GID of a computation node where work can be sent to be processed. 

Ideally, it should return the computation node with the lowest load. However, because the function may be called multiple times before the first parcel is sent out, returning the lowest load CPU may cause too many parcels to be sent to one destination. (Therefore, it is probably best to return GIDs in round-robin fashion) 

Mstack currently implements a hack to avoid this problem (under the comment "get all non-local GIDS and store six of them", lines 165-181). It iterates through all GIDs, and stores the first few (6 in Mstack's case) for later use. 


(3) The small one: DGAS runtime should have a command-line option to run a DGAS service only 
The DGAS runtime, as it is currently written (in ../../runtime/hpx_runtime.cpp) always launches both a full HPX runtime and the DGAS service (on two different ports). 

The former of these is likely to lead to a misallocation of work. (It is roughly equivalent to running heavy duty scientific code on the department mail server) The hpx runtime should be modified so that it has a command line option to launch only a DGAS server. 

I discovered this problem because when using the hack described in (2) above, I ended up doing exactly that - running Mstack source code on the DGAS server. At Hartmut's suggestion, I have created a pure (DGAS only) runtime. The source is in ../../runtime/hpx_runtime_pure.cpp 

(4) The smallest one: Cmake does not compile with built-in support for debugging. 
Unless there is negative impact I'm not aware of, all Cmake files in HPX should by-default compile binaries with built-in support for debugging. 

